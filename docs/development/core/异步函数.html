<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <p>    body {
        display: flex;
        margin: 0;
        height: 100vh;
    }

    aside {
        width: 200px;
        background: #f0f0f0;
        padding: 20px;
    }

    main {
        flex: 1;
        padding: 20px;
    }</p>
    <ul>
      <li><a href="index">index</a></li>
      <li>
        <p>d1</p>
        <ul>
          <li><a href="d1/f1">f1</a></li>
        </ul>
      </li>
    </ul>
    <h2>异步函数</h2>
    <p>也许你常有这样的烦恼（实则不然）：你需要在主线程上处理一些事物，但是其中你想进行一些延迟，显然你不能睡在主线程上</p>
    <h3>设置定时任务</h3>
    <p>最常见的方式就是创建一个计划任务了，服务端实例可以代表主线程的调度器</p>
    <div style="border: 1pt solid #7fdbff;
">java</div>
    <div style="border: 1pt solid #7fdbff;
">
      <pre><code class="language-java">MinecraftServer.instance.schedule(() ->
{
    System.out.println("Hello World");
}, new SleepTicks(20));</code></pre>
    </div>
    <p>这将会在主线程的20个ticks后打印Hello World</p>
    <p>其中<code>SleepTicks</code>的实例是被<code>MinecraftServer#schedule</code>处理的，实现了任务的创建</p>
    <h3>创建异步函数</h3>
    <p>你显然不太满意计划任务，因为它容易是你陷入回调地狱，因此我们使用嵌入控制流的延迟方法</p>
    <p>首先你需要创建一个类并继承<code>AsyncFunction&lt;R></code>，其中R是返回值类型。这个类就表示一个异步函数，我们暂时先返回Void</p>
    <div style="border: 1pt solid #7fdbff;
">java</div>
    <div style="border: 1pt solid #7fdbff;
">
      <pre><code class="language-java">public class MyAsyncFunction extends AsyncFunction&lt;Void>
{
    // 实现template，异步函数的逻辑写在这里
    @Override
    public Void template()
    {
        // 循环5次
        for(int i=0; i&lt;5; i++)
        {
            // 打印Hello World
            System.out.println("Hello World");
            // “调用” await，延迟20个ticks
            await(new SleepTicks(20));
        }
        return null;
    }

    // 实现run方法，方法体留空
    @Override
    public void run()
    {
    }
}</code></pre>
    </div>
    <p>这里的await是异步函数让步的一个标记，并不是真正调用了这个方法</p>
    <h3>启动异步函数</h3>
    <p>调用异步函数后，你可以认为它启动了一个协程，因此我们先构造它，然后调用start方法来启动</p>
    <div style="border: 1pt solid #7fdbff;
">java</div>
    <div style="border: 1pt solid #7fdbff;
">
      <pre><code class="language-java">new MyAsyncFunction().start(MinecraftServer.instance);</code></pre>
    </div>
    <p><code>start</code>方法的参数就是这个异步函数的runner，<code>MinecraftServer.instance</code>则让它在主线程中运行</p>
    <p>异步函数<code>await</code>的<code>SleepTicks</code>实例也由<code>MinecraftServer.instance</code>处理</p>
    <p>异步函数启动后<code>start</code>方法会返回一个<code>CompletableFuture&lt;R></code>实例，当异步函数返回时它被完成</p>
    <h3>等待CompletableFuture</h3>
    <p>在异步函数中，你可以等待一个CompletableFuture的完成</p>
    <p>例如，你可以启动另一个异步函数并等待</p>
    <div style="border: 1pt solid #7fdbff;
">java</div>
    <div style="border: 1pt solid #7fdbff;
">
      <pre><code class="language-java">public class MyAsyncFunction2 extends AsyncFunction&lt;Void>
{
    // 实现template，异步函数的逻辑写在这里
    @Override
    public Void template()
    {
        System.out.println("Hello CompletableFuture");
        // 使用相同的runner启动MyAsyncFunction，得到其CompletableFuture
        CompletableFuture&lt;Void> cf = new MyAsyncFunction().start(this.getRunner());
        // 使用await0等待它完成
        await0(cf);
        System.out.println("Hello CompletableFuture");
        return null;
    }

    // 实现run方法，方法体留空
    @Override
    public void run()
    {
    }
}</code></pre>
    </div>
    <h3>在匿名内部类中使用</h3>
    <p>你也许想到：作为函数，异步函数应当可以有参数，但这样你需要创建构造器传入参数到字段，然后在<code>template</code>中使用</p>
    <p>将异步函数写成匿名内部类并封装成方法可能会简化许多</p>
    <div style="border: 1pt solid #7fdbff;
">java</div>
    <div style="border: 1pt solid #7fdbff;
">
      <pre><code class="language-java">public static AsyncFunction&lt;Void> newMyAsyncFunction(int i)
{
    return new AsyncFunction&lt;Void>()
    {
        public Void template()
        {
            System.out.println("Hello World " + i);
        }
        public void run()
        {
        }
    };
}</code></pre>
    </div>
    <p>通常情况下，如果你需要一个固定的runner，那你可以直接调用<code>start</code>再返回<code>CompletableFuture</code></p>
    <div style="border: 1pt solid #7fdbff;
">java</div>
    <div style="border: 1pt solid #7fdbff;
">
      <pre><code class="language-java">public static CompletableFuture&lt;Void> startMyAsyncFunction(int i)
{
    return new AsyncFunction&lt;Void>()
    {
        public Void template()
        {
            await(new SleepTicks(20));
            System.out.println("Hello World " + i);
        }
        public void run()
        {
        }
    }.start(MinecraftServer.instance);
}</code></pre>
    </div>
  </body>
</html>
